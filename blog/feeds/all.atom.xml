<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Feature creep designer</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2013-01-09T22:08:29+01:00</updated><entry><title>Django with Sentry</title><link href="/django-with-sentry.html" rel="alternate"></link><updated>2013-01-09T22:08:29+01:00</updated><author><name>lqez</name></author><id>tag:,2013-01-09:django-with-sentry.html</id><summary type="html">&lt;p&gt;Sentry&lt;/p&gt;
&lt;p&gt;&lt;a href="https://getsentry.com/"&gt;https://getsentry.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exceptional error aggregation.&lt;/p&gt;
&lt;p&gt;Streamline app maintenance and debugging inreal-time with Sentry.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sentry는 위와 같이 스스로를 정의하고 있는,Django 기반의에러/로그 수집기이다.&lt;/p&gt;
&lt;p&gt;내장된 TCP/UDP 서버로 동작하며, Python, PHP, Ruby, Node.js, Java 등의 에러와 로그를 수집할 수 있다.&lt;/p&gt;
&lt;p&gt;특히, 잘 알려진 웹 프레임워크인 Django, Flask, Rails, Express 등과 복잡한 설정 없이 잘 달라붙어 효과적인 에러
수집과 분석이 가능한 것이 강점이다.&lt;/p&gt;
&lt;p&gt;BSD 라이센스로 공개되어 있어
&lt;a href="https://github.com/getsentry/sentry"&gt;https://github.com/getsentry/sentry&lt;/a&gt; 를
통해 직접 내려받아 설치해서 운용할 수도 있고,&lt;/p&gt;
&lt;p&gt;설치가 귀찮은 경우
&lt;a href="https://www.getsentry.com/pricing/"&gt;https://www.getsentry.com/pricing/&lt;/a&gt;을 통해
호스팅으로 운용할 수 있는 것도 장점이다.&lt;/p&gt;
&lt;p&gt;설치는&lt;a href="http://sent
ry.readthedocs.org/en/latest/quickstart/index.html"&gt;http://sentry.readthedocs.org/en/latest/quickstart/index.html&lt;/a&gt; 를 참고하여 손쉽게 진행할 수 있으므로
생략한다.&lt;/p&gt;
&lt;p&gt;Sentry in SMARTSTUDY&lt;/p&gt;
&lt;p&gt;서비스하는 앱이 하이브리드 형태라 각종 페이지가 Django로 구축되어 있는데, 이들 서비스의 에러 로그를 수집하는데 사용하고 있다.&lt;/p&gt;
&lt;p&gt;아래는 설치하여 사용하고 있는 Sentry의 스크린샷이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.10.04_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;설정이 끝난 Sentry의 첫 화면이다. html canvas를 이용한 로그 수집 양에 대한 그래프와 함께, 지난 24시간 동안 보고된
에러를 종류 별로 구분하여 보여주고 있다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.10.17_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;에러를 하나 선택하면, 해당 에러에 대한 HTTP Request 정보를 보여준다.&lt;/p&gt;
&lt;p&gt;문제를 일으킨 상황을 다시 재연(replay this request)할 수 있어 문제 해결에 도움이 된다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.10.24_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;해당 문제를 발생시킨 소스 스택과 요청 값에 대한 상세한 내용과 함께, 브라우저 / 서버 / URL / 사용자별 통계를 같이 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.10.42_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;위에서 언급했던 웹 프레임워크에 대해서는 사용자 정보 등 자세한 정보를 포함해서 더 용이한 분석을 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.11.56_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;해결된 에러에 대해서는 체크 버튼을 눌러 해당 이슈가 처리되었음을 표시할 수 있다.&lt;/p&gt;
&lt;p&gt;Stream 페이지는 리스트를 지속적으로 폴링하여, 에러가 발생한 경우 준 실시간급으로 업데이트되는 것이 인상적이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.11.43_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.10.54_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;프로젝트와 사용자 / 팀 관리 메뉴를 갖추고 있으며, LDAP 로그인, Gravatar 등을 지원한다.&lt;/p&gt;
&lt;p&gt;애초에 Django 기반인데다, 자체적인 Sentry plugin 시스템도 제공하여 필요한 기능을 손쉽게 확장할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sentry.rea
dthedocs.org/en/latest/plugins/index.html"&gt;http://sentry.readthedocs.org/en/latest/plugins/index.html&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>Spine + Poller 설정으로 cacti 성능 향상하기</title><link href="/spine-poller-seoljeongeuro-cacti-seongneung-hyangsanghagi.html" rel="alternate"></link><updated>2013-01-09T22:08:29+01:00</updated><author><name>lqez</name></author><id>tag:,2013-01-09:spine-poller-seoljeongeuro-cacti-seongneung-hyangsanghagi.html</id><summary type="html">&lt;p&gt;Cacti에 대해서 잘 모를 때에 - 지금도 잘 모르지만 - "cacti는 크롤러가 단일 프로세스라서 짜증나요" 같은 얘기를 하고 다녔는데
모두 취소.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Cacti에서 크롤러(poller) 역할을 하는 cmd.php를 단일 프로세스가 아니라, 여러 프로세스로 동작시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래도 성능이 부족한 경우 spine을 설치하여 multi process + multi thread 로 성능을 더 향상시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;spine
:&lt;a href="http://www.cacti.net/spine_info.php"&gt;http://www.cacti.net/spine_info.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="Screen_Shot_2013-01-09_at_3.25.04_PM.png" /&gt;&lt;/p&gt;
&lt;p&gt;멀쩡하게 존재하는 concurrent 및 spine 관련 옵션.capture&lt;/p&gt;
&lt;p&gt;혹시라도 poller 속도에 불만을 가진 사람이라면 꼭 spine을 설치하지 않아도 Maximum Concurrent Poller
Processes 값만 조정해도 퍼포먼스 향상이 될 듯.&lt;/p&gt;
&lt;p&gt;단일 프로세스로 수행하던 때에는 조금 지연되면 몇 분씩 걸리는 경우도 있었는데, 4 processes x 16 threads 로 사용하는
지금은 10초 이내로 처리 끝.&lt;/p&gt;</summary></entry><entry><title>Using Nginx with LDAP authentication</title><link href="/using-nginx-with-ldap-authentication.html" rel="alternate"></link><updated>2013-01-09T22:08:29+01:00</updated><author><name>lqez</name></author><id>tag:,2013-01-09:using-nginx-with-ldap-authentication.html</id><summary type="html">&lt;p&gt;Nginx는 비동기 이벤트 기반 웹 서버다. 더 이상의 자세한 설명은 생략한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nginx.org/"&gt;http://www.nginx.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ko.wikipedia.org/wiki/Nginx"&gt;http://ko.wikipedia.org/wiki/Nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사내외로 골고루 사용하던 Apache httpd 웹 서버 - 라 쓰고 종합 선물 세트라고 읽는다 - 를 대체하기 위해 Nginx 를 도입하던
중, 대부분의 이슈를 해결하였으나 LDAP 인증이 기본 모듈에 없어, 애플리케이션 레벨에서 다룰까하다 검색해보니 서드파티 플러그인으로
nginx-auth-ldap 이 있어 사용해보았다.&lt;/p&gt;
&lt;p&gt;이하 작업은 Ubuntu 12.04(precise) 를 기준으로 작업한 내용을 정리한 것이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get Nginx&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://nginx.org/en/download.html"&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위 경로에서 적절한 파일을 받는다. 실제 서비스를 위해서는 되도록 stable release를 받는 것이 좋겠다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get previous configuration&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-V 옵션을 통해 기존에 사용하던 Nginx 를 빌드하기 위해 사용한 옵션을 확인할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ ./nginx -V&lt;/p&gt;
&lt;p&gt;nginx version: nginx/1.1.19&lt;/p&gt;
&lt;p&gt;TLS SNI support enabled&lt;/p&gt;
&lt;p&gt;configure arguments: --prefix=/etc/nginx --conf-path=/etc/nginx/nginx.conf
--error-log-path=/var/log/nginx/error.log --http-client-body-temp-
path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi
--http-log-path=/var/log/nginx/access.log --http-proxy-temp-
path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-
uwsgi-temp-path=/var/lib/nginx/uwsgi --lock-path=/var/lock/nginx.lock --pid-
path=/var/run/nginx.pid --with-debug --with-http_addition_module --with-
http_dav_module --with-http_geoip_module --with-http_gzip_static_module
--with-http_image_filter_module --with-http_realip_module --with-
http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-
http_xslt_module --with-ipv6 --with-sha1=/usr/include/openssl --with-
md5=/usr/include/openssl --with-mail --with-mail_ssl_module --add-
module=/build/buildd/nginx-1.1.19/debian/modules/nginx-auth-pam --add-
module=/build/buildd/nginx-1.1.19/debian/modules/nginx-echo --add-
module=/build/buildd/nginx-1.1.19/debian/modules/nginx-upstream-fair --add-
module=/build/buildd/nginx-1.1.19/debian/modules/nginx-dav-ext-module&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Get nginx-auth-ldap&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://github.com/kvspb/nginx-
auth-ldap"&gt;https://github.com/kvspb/nginx-auth-ldap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세상엔 친절한 사람이 의외로 많은데, 역시 누군가 만들어 공개해두었다. 아래와 같이 git clone 하여 받아둔다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ git clone https://github.com/kvspb/nginx-auth-ldap.git&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Configuration and Build&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;미리 확인해둔 옵션에 nginx-auth-ldap 페이지의 설명에서와 같이--add-module 옵션으로 nginx-auth-ldap
디렉토리를 지정하여, 같이 빌드하도록 한다.&lt;/p&gt;
&lt;p&gt;필요 없는 모듈은 일부 삭제하여, 아래와 같은 설정으로 빌드하였다. 자신에게 맞는 빌드 옵션을
&lt;a href="http://wiki.nginx.org/InstallOptions"&gt;http://wiki.nginx.org/InstallOptions&lt;/a&gt; 를
통해 확인하여 지정하도록 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ nginx -V&lt;/p&gt;
&lt;p&gt;nginx version: nginx/1.2.6&lt;/p&gt;
&lt;p&gt;built by gcc 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)&lt;/p&gt;
&lt;p&gt;TLS SNI support enabled&lt;/p&gt;
&lt;p&gt;configure arguments: --prefix=/etc/nginx &lt;strong&gt;--sbin-path=/usr/sbin&lt;/strong&gt; --conf-
path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-
client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-
path=/var/lib/nginx/fastcgi --http-log-path=/var/log/nginx/access.log --http-
proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi
--http-uwsgi-temp-path=/var/lib/nginx/uwsgi --lock-path=/var/lock/nginx.lock
--pid-path=/var/run/nginx.pid --with-debug --with-http_addition_module --with-
http_dav_module --with-http_geoip_module --with-http_gzip_static_module
--with-http_image_filter_module --with-http_realip_module --with-
http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-
ipv6 --with-sha1=/usr/include/openssl --with-md5=/usr/include/openssl &lt;strong&gt;--add-
module=/home/ez/nginx-auth-ldap&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 글을 읽을 분들은 당연히 configure나 make에 익숙할거라 생각하지만, 혹시나 하여 적어본다. libpcre3-dev 나
libssl-dev 등 빌드에 필요한 패키지는 미리 받아두도록 하자.&lt;/p&gt;
&lt;p&gt;GD 관련 라이브러리를 달라고 에러를 뱉는 경우가 있는데, 이 때는 libgd2-xpm-dev 등을 받으면 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ ./configure --prefix=/etc/nginx ... (생략)&lt;/p&gt;
&lt;p&gt;$ make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Packaging and Install&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아래와 같이 checkinstall 을 이용해 deb 패키징 후 설치하거나, 간단하게 sudo make install 로도 설치할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ sudo checkinstall&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;checkinstall 을 통해 설치하다가, 기존 설치본 때문에 설치할 수 없다는 에러가 발생하면, 아래와 같이 덮어쓰기 옵션을 추가하여
설치할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ sudo dpkg -i --force-overwrite &lt;package_file&gt;.deb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;LDAP configuration&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;foo.com 의 admin 경로에 대해 LDAP 인증을 추가한다고 가정한다.&lt;/p&gt;
&lt;p&gt;/etc/nginx/sites-available 에 있는 사이트별 설정파일에서 foo.com 에 해당하는 파일을 열어, 아래와 같이
수정한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;server {&lt;/p&gt;
&lt;p&gt;listen 80;&lt;/p&gt;
&lt;p&gt;server_name foo.com &lt;a href="http://www.foo.com;"&gt;www.foo.com;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(...생략...)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; auth_ldap_url
ldap://ldap.foo.com/dc=foo,dc=com?uid?sub?(objectClass=person);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; location /admin {&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; auth_ldap "Administrator page";&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; auth_ldap_require valid_user;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; } &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그룹 등의 다양한 설정에 대해서는 다음 링크를 참조한다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kvspb/nginx-auth-
ldap/blob/master/example.conf"&gt;https://github.com/kvspb/nginx-auth-
ldap/blob/master/example.conf&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>the very first blogging via pelican.</title><link href="/the-first-blog-post-en.html" rel="alternate"></link><updated>2012-11-11T23:33:17+01:00</updated><author><name>lqez</name></author><id>tag:,2012-11-11:the-first-blog-post-en.html</id><summary type="html">&lt;p&gt;Ah, ha!&lt;/p&gt;
</summary><category term="test"></category></entry></feed>